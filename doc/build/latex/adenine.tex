% Generated by Sphinx.
\def\sphinxdocclass{report}
\newif\ifsphinxKeepOldNames \sphinxKeepOldNamestrue
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage{iftex}

\ifPDFTeX
  \usepackage[utf8]{inputenc}
\fi
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}




\title{adenine Documentation}
\date{Mar 01, 2017}
\release{0.1.4}
\author{Samuele Fiorini - Federico Tomasi - Annalisa Barla}
\newcommand{\sphinxlogo}{\sphinxincludegraphics{adenine_logo.png}\par}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


\textbf{adenine} is a machine learning and data mining Python library for exploratory data analysis.

The main structure of \textbf{adenine} can be summarized in the following 4 steps.
\begin{enumerate}
\item {} 
\textbf{Imputing:} Does your dataset have missing entries? In the first step you can fill the missing values choosing between different strategies: feature-wise median, mean and most frequent value or k-NN imputing.

\item {} 
\textbf{Preprocessing:} Have you ever wondered what would have changed if only your data have been preprocessed in a different way? Or is it data preprocessing a good idea after all? \textbf{adenine} includes several preprocessing procedures, such as: data recentering, Min-Max scaling, standardization and normalization. \textbf{adenine} also allows you to compare the results of the analysis made with different preprocessing strategies.

\item {} 
\textbf{Dimensionality Reduction:} In the context of data exploration, this phase becomes particularly helpful for high dimensional data. This step includes manifold learning (such as isomap, multidimensional scaling, etc) and unsupervised feature learning (principal component analysis, kernel PCA, Bernoulli RBM, etc) techniques.

\item {} 
\textbf{Clustering:} This step aims at grouping data into clusters in an unsupervised manner. Several techniques such as k-means, spectral or hierarchical clustering are offered.

\end{enumerate}

The final output of \textbf{adenine} is a compact, textual and graphical representation of the results obtained from the pipelines made with each possible combination of the algorithms selected at each step.

\textbf{adenine} can run on multiple cores/machines* and it is fully \sphinxtitleref{scikit-learn} compliant.


\chapter{User documentation}
\label{index:adenine-a-data-exploration-pipeline}\label{index:user-documentation}

\section{Quick start tutorial}
\label{tutorial::doc}\label{tutorial:quick-start-tutorial}\label{tutorial:tutorial}
\textbf{Adenine*} can be installed using standard Python tools (with
administrative or sudo permissions on GNU-Linux platforms):

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} pip install adenine
\end{Verbatim}


\subsection{Installation from sources}
\label{tutorial:installation-from-sources}
If you like to manually install \textbf{Adenine}, download the .zip or .tar.gz archive
from \url{http://slipguru.github.io/adenine/}. Then extract it and move into the root directory:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} unzip slipguru\PYGZhy{}adenine\PYGZhy{}\textbar{}release\textbar{}.zip
\PYGZdl{} cd adenine\PYGZhy{}\textbar{}release\textbar{}/
\end{Verbatim}

or:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} tar xvf slipguru\PYGZhy{}adenine\PYGZhy{}\textbar{}release\textbar{}.tar.gz
\PYGZdl{} cd adenine\PYGZhy{}\textbar{}release\textbar{}/
\end{Verbatim}

Otherwise you can clone our \href{https://github.com/slipguru/adenine}{GitHub repository}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} git clone https://github.com/slipguru/adenine.git
\end{Verbatim}

From here, you can follow the standard Python installation step:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} python setup.py install
\end{Verbatim}

After \textbf{Adenine} installation, you should have access to two scripts,
named with a common \sphinxcode{ade\_} prefix:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ade\PYGZus{}\PYGZlt{}TAB\PYGZgt{}
ade\PYGZus{}analysis.py    ade\PYGZus{}run.py
\end{Verbatim}

This tutorial assumes that you downloaded and extracted \textbf{Adenine}
source package which contains a \sphinxcode{examples\textbackslash{}data} directory with some data files (\sphinxcode{.npy} or \sphinxcode{.csv}) which will be used to show \textbf{Adenine} functionalities.

\textbf{Adenine} needs only 3 ingredients:
\begin{itemize}
\item {} 
\sphinxcode{n\_samples x n\_variables} input matrix

\item {} 
\sphinxcode{n\_samples x 1} output vector (optional)

\item {} 
\sphinxcode{configuration} file

\end{itemize}


\subsection{Input data format}
\label{tutorial:input-data-format}
Input data are assumed to be:
\begin{itemize}
\item {} 
\sphinxcode{numpy} array stored in \sphinxcode{.npy} files organized with a row for each sample and a column for each feature,

\item {} 
tabular data stored in comma separated \sphinxcode{.csv} files presenting the variables header on the first row and the sample indexes on the first column,

\item {} 
toy examples available from \sphinxcode{adenine.utils.data\_source} function.

\end{itemize}


\subsection{Configuration File}
\label{tutorial:configuration-file}\label{tutorial:configuration}
\textbf{Adenine} configuration file is a standard Python script. It is
imported as a module, then all the code is executed. In this file the user can define all the option needed to read the data and to create the pipelines.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/usr/bin/env python}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}*\PYGZhy{} coding: utf\PYGZhy{}8 \PYGZhy{}*\PYGZhy{}}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Configuration file for adenine.\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k+kn}{from} \PYG{n+nn}{adenine.utils} \PYG{k+kn}{import} \PYG{n}{data\PYGZus{}source}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  EXPERMIENT INFO \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZsh{}}
\PYG{n}{exp\PYGZus{}tag} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}experiment}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{output\PYGZus{}root\PYGZus{}folder} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{results}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{plotting\PYGZus{}context} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{notebook}\PYG{l+s+s1}{\PYGZsq{}}  \PYG{c+c1}{\PYGZsh{} one of \PYGZob{}paper, notebook, talk, poster\PYGZcb{}}
\PYG{n}{file\PYGZus{}format} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pdf}\PYG{l+s+s1}{\PYGZsq{}}  \PYG{c+c1}{\PYGZsh{} or \PYGZsq{}png\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  INPUT DATA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} Load an example dataset or specify your input data in tabular format}
\PYG{n}{data\PYGZus{}file} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{data.csv}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{labels\PYGZus{}file} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{labels.csv}\PYG{l+s+s1}{\PYGZsq{}}  \PYG{c+c1}{\PYGZsh{} OPTIONAL}
\PYG{n}{samples\PYGZus{}on} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rows}\PYG{l+s+s1}{\PYGZsq{}}  \PYG{c+c1}{\PYGZsh{} if samples lie on columns use \PYGZsq{}cols\PYGZsq{} or \PYGZsq{}col\PYGZsq{}}
\PYG{n}{data\PYGZus{}sep} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}  \PYG{c+c1}{\PYGZsh{} the data separator. e.g., \PYGZsq{},\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{} \PYGZsq{}, ...}
\PYG{n}{X}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{feat\PYGZus{}names}\PYG{p}{,} \PYG{n}{index} \PYG{o}{=} \PYG{n}{data\PYGZus{}source}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{custom}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                           \PYG{n}{data\PYGZus{}file}\PYG{p}{,} \PYG{n}{labels\PYGZus{}file}\PYG{p}{,}
                                           \PYG{n}{samples\PYGZus{}on}\PYG{o}{=}\PYG{n}{samples\PYGZus{}on}\PYG{p}{,}
                                           \PYG{n}{sep}\PYG{o}{=}\PYG{n}{data\PYGZus{}sep}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  PIPELINES DEFINITION \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{} Missing values imputing \PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZsh{}}
\PYG{n}{step0} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Impute}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{missing\PYGZus{}values}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{NaN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{strategy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{median}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mean}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nearest\PYGZus{}neighbors}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{} Data preprocessing \PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZsh{}}
\PYG{n}{step1} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{None}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n+nb+bp}{False}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Recenter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n+nb+bp}{False}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Standardize}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n+nb+bp}{False}\PYG{p}{]}\PYG{p}{,}
         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Normalize}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{norm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{l1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{l2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{,}
         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{MinMax}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{feature\PYGZus{}range}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{} Unsupervised features learning \PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} affinity ca be precumputed for SE}
\PYG{n}{step2} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PCA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n\PYGZus{}components}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{,}
         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{IncrementalPCA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n+nb+bp}{False}\PYG{p}{]}\PYG{p}{,}
         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RandomizedPCA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n+nb+bp}{False}\PYG{p}{]}\PYG{p}{,}
         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{KernelPCA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{kernel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{linear}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rbf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{poly}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{,}
         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Isomap}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n\PYGZus{}neighbors}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{,}
         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LLE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n\PYGZus{}neighbors}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{5}\PYG{p}{,}
                         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{method}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{standard}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{modified}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hessian}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ltsa}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{,}
         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{SE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{affinity}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nearest\PYGZus{}neighbors}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rbf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{,}
         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{MDS}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{metric}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n+nb+bp}{True}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{,}
         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tSNE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n+nb+bp}{False}\PYG{p}{]}\PYG{p}{,}
         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RBM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n\PYGZus{}components}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{256}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{,}
         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{None}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n+nb+bp}{False}\PYG{p}{]}
         \PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{} Clustering \PYGZhy{}\PYGZhy{}\PYGZhy{} \PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} affinity ca be precumputed for AP, Spectral and Hierarchical}
\PYG{n}{step3} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{KMeans}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n\PYGZus{}clusters}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{auto}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{,}
         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{AP}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{preference}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{auto}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{,}
         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{MS}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n+nb+bp}{False}\PYG{p}{]}\PYG{p}{,}
         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Spectral}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n\PYGZus{}clusters}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{,}
         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hierarchical}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n\PYGZus{}clusters}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{,}
                                  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{affinity}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{manhattan}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{euclidean}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
                                  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{linkage}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}  \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ward}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{complete}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{average}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
         \PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsection{Experiment runner}
\label{tutorial:experiment}\label{tutorial:experiment-runner}
The \sphinxcode{ade\_run.py} script, executes the full \textbf{Adenine} framework. The prototype is the following:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ade\PYGZus{}run.py ade\PYGZus{}config.py
\end{Verbatim}

When launched, the script reads the data, then it creates and runs each pipeline saving the results in a tree-like structure which has the current folder as root.


\subsection{Results analysis}
\label{tutorial:results-analysis}\label{tutorial:analysis}
The \sphinxcode{ade\_analysis.py} script provides useful summaries and graphs from the results of the experiment. This script accepts as only parameter a result directory
already created:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ade\PYGZus{}analysis.py result\PYGZhy{}dir
\end{Verbatim}

The script produces a set of textual and graphical results. An output example obtained by one of the implemented pipelines is represented below.

\noindent\scalebox{0.800000}{\sphinxincludegraphics{{pca}.png}}

\noindent\scalebox{0.800000}{\sphinxincludegraphics{{kpca}.png}}

You can reproduce the example above specifying \sphinxcode{data\_source.load('circles')} in the configuration file.


\subsection{Example dataset}
\label{tutorial:example-dataset}
An example dataset can be dowloaded \sphinxcode{here}. The dataset is a random extraction of 801 samples (with dimension 20531) measuring RNA-Seq gene expression of patients affected by 5 different types of tumor: breast invasive carcinoma (BRCA), kidney renal clear cell carcinoma (KIRC), colon  (COAD), lung  (LUAD) and prostate adenocarcinoma (PRAD). The full dataset is maintained by The Cancer Genome Atlas Pan-Cancer Project {[}1{]} and we refer to the \href{https://www.synapse.org/\#!Synapse:syn4301332}{original repository} for furher details.


\subsection{Reference}
\label{tutorial:reference}
{[}1{]} Weinstein, John N., et al. ``The cancer genome atlas pan-cancer analysis project.'' Nature genetics 45.10 (2013): 1113-1120.


\section{API}
\label{index:api}\label{index:id1}

\subsection{Pipeline utilities}
\label{index:module-adenine.core.define_pipeline}\label{index:pipeline-utilities}\index{adenine.core.define\_pipeline (module)}\index{parse\_imputing() (in module adenine.core.define\_pipeline)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.core.define_pipeline.parse_imputing}\pysiglinewithargsret{\sphinxcode{adenine.core.define\_pipeline.}\sphinxbfcode{parse\_imputing}}{\emph{key}, \emph{content}}{}
Parse the options of the imputing step.

This function parses the imputing step coded as dictionary in the
ade\_config file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{key} : class or str, like \{`Impute', `None'\}
\begin{quote}

The type of selected imputing step. In case in which key
is a \sphinxtitleref{class}, it must contain both a \sphinxtitleref{fit} and \sphinxtitleref{transform} method.
\end{quote}

\textbf{content} : dict
\begin{quote}

A dictionary containing parameters for each imputing
class. Each parameter can be a list; in this case for each combination
of parameters a different pipeline will be created.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{tpl} : tuple
\begin{quote}

A tuple made like (`imputing\_name', imputing\_obj, `imputing'),
where imputing\_obj is an sklearn `transforms' (i.e. it has bot a fit
and transform method).
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{parse\_preproc() (in module adenine.core.define\_pipeline)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.core.define_pipeline.parse_preproc}\pysiglinewithargsret{\sphinxcode{adenine.core.define\_pipeline.}\sphinxbfcode{parse\_preproc}}{\emph{key}, \emph{content}}{}
Parse the options of the preprocessing step.

This function parses the preprocessing step coded as dictionary in the
ade\_config file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{key} : class or str, like \{`None', `Recenter', `Standardize', `Normalize',
\begin{quote}
\begin{quote}

`MinMax'\}
\end{quote}

The selected preprocessing algorithm. In case in which key
is a \sphinxtitleref{class}, it must contain both a \sphinxtitleref{fit} and \sphinxtitleref{transform} method.
\end{quote}

\textbf{content} : dict
\begin{quote}

A dictionary containing parameters for each preprocessing
class. Each parameter can be a list; in this case for each combination
of parameters a different pipeline will be created.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{tpl} : tuple
\begin{quote}

A tuple made like (`preproc\_name', preproc\_obj, `preproc'), where
preproc\_obj is an sklearn `transforms' (i.e. it has bot a fit and
transform method).
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{parse\_dimred() (in module adenine.core.define\_pipeline)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.core.define_pipeline.parse_dimred}\pysiglinewithargsret{\sphinxcode{adenine.core.define\_pipeline.}\sphinxbfcode{parse\_dimred}}{\emph{key}, \emph{content}}{}
Parse the options of the dimensionality reduction step.

This function does the same as parse\_preproc but works on the
dimensionality reduction \& manifold learning options.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{key} : class or str, like \{`None', `PCA', `KernelPCA', `Isomap', `LLE',
\begin{quote}
\begin{quote}

`SE', `MDS', `tSNE', `RBM'\}
\end{quote}

The selected dimensionality reduction algorithm. In case in which key
is a \sphinxtitleref{class}, it must contain both a \sphinxtitleref{fit} and \sphinxtitleref{transform} method.
\end{quote}

\textbf{content} : dict
\begin{quote}

A dictionary containing parameters for each dimensionality reduction
class. Each parameter can be a list; in this case for each combination
of parameters a different pipeline will be created.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{tpl} : tuple
\begin{quote}

A tuple made like (`dimres\_name', dimred\_obj, `dimred'), where
dimred\_obj is a sklearn `transforms' (i.e. it has bot a .fit and .transform method).
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{parse\_clustering() (in module adenine.core.define\_pipeline)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.core.define_pipeline.parse_clustering}\pysiglinewithargsret{\sphinxcode{adenine.core.define\_pipeline.}\sphinxbfcode{parse\_clustering}}{\emph{key}, \emph{content}}{}
Parse the options of the clustering step.

This function does the same as parse\_preproc but works on the clustering
options.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{key} : class or str, like \{`KMeans', `AP', `MS', `Spectral', `Hierarchical'\}
\begin{quote}

The selected clustering algorithm. In case in which key
is a \sphinxtitleref{class}, it must contain a \sphinxtitleref{fit} method.
\end{quote}

\textbf{content} : dict
\begin{quote}

A dictionary containing parameters for each clustering class.
Each parameter can be a list; in this case for each combination
of parameters a different pipeline will be created.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{tpl} : tuple
\begin{quote}

A tuple made like (`clust\_name', clust\_obj, `clustering'), where
clust\_obj implements the \sphinxtitleref{fit} method.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{parse\_steps() (in module adenine.core.define\_pipeline)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.core.define_pipeline.parse_steps}\pysiglinewithargsret{\sphinxcode{adenine.core.define\_pipeline.}\sphinxbfcode{parse\_steps}}{\emph{steps}, \emph{max\_n\_pipes=200}}{}
Parse the steps and create the pipelines.

This function parses the steps coded as dictionaries in the ade\_config
files and creates a sklearn pipeline objects for each combination of
imputing -\textgreater{} preprocessing -\textgreater{} dimensionality reduction -\textgreater{} clustering
algorithms.
\begin{description}
\item[{A typical step may be of the following form:}] \leavevmode
stepX = \{`Algorithm': {[}On/Off flag, \{`parameter1', {[}list of params{]}\}{]}\}

\end{description}

where On/Off flag = \{True, False\} and `list of params' allows to specify
multiple params. In case in which the `list of params' is actually a list,
multiple pipelines are created for each combination of parameters.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{steps} : list of dictionaries
\begin{quote}

A list of (usually 4) dictionaries that contains the details of the
pipelines to implement.
\end{quote}

\textbf{max\_n\_pipes} : int, optional, default: 200
\begin{quote}

The maximum number of combinations allowed. This avoids a too expensive
computation.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{pipes} : list of sklearn.pipeline.Pipeline
\begin{quote}

The returned list must contain every possible combination of
imputing -\textgreater{} preprocessing -\textgreater{} dimensionality reduction -\textgreater{} clustering
algorithms (up to max\_n\_pipes).
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\phantomsection\label{index:module-adenine.core.pipelines}\index{adenine.core.pipelines (module)}\index{create() (in module adenine.core.pipelines)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.core.pipelines.create}\pysiglinewithargsret{\sphinxcode{adenine.core.pipelines.}\sphinxbfcode{create}}{\emph{pdef}}{}
Scikit-learn Pipelines objects creation (deprecated).

This function creates a list of sklearn Pipeline objects starting from the
list of list of tuples given in input that could be created using the
adenine.core.define\_pipeline module.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{pdef} : list of list of tuples
\begin{quote}

This arguments contains the specification needed by sklearn in order
to create a working Pipeline object.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{pipes} : list of sklearn.pipeline.Pipeline objects
\begin{quote}

The list of Piplines, each of them can be fitted and trasformed
with some data.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{which\_level() (in module adenine.core.pipelines)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.core.pipelines.which_level}\pysiglinewithargsret{\sphinxcode{adenine.core.pipelines.}\sphinxbfcode{which\_level}}{\emph{label}}{}
Define the step level according to the input step label {[}DEPRECATED{]}.

This function return the level (i.e.: imputing, preproc, dimred, clustring,
None) according to the step label provided as input.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{label} : string
\begin{quote}

This is the step level as it is reported in the ade\_config file.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{level} : \{imputing, preproc, dimred, clustering, None\}
\begin{quote}

The appropriate level of the input step.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{evaluate() (in module adenine.core.pipelines)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.core.pipelines.evaluate}\pysiglinewithargsret{\sphinxcode{adenine.core.pipelines.}\sphinxbfcode{evaluate}}{\emph{level}, \emph{step}, \emph{X}}{}
Transform or predict according to the input level.

This function uses the transform or the predict method on the input
sklearn-like step according to its level (i.e. imputing, preproc, dimred,
clustering, none).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{level} : \{`imputing', `preproc', `dimred', `clustering', `None'\}
\begin{quote}

The step level.
\end{quote}

\textbf{step} : sklearn-like object
\begin{quote}

This might be an Imputer, or a PCA, or a KMeans (and so on...)
sklearn-like object.
\end{quote}

\textbf{X} : array of float, shape
\begin{quote}

The input data matrix.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{res} : array of float
\begin{quote}

A matrix projection in case of dimred, a label vector in case of
clustering, and so on.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{pipe\_worker() (in module adenine.core.pipelines)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.core.pipelines.pipe_worker}\pysiglinewithargsret{\sphinxcode{adenine.core.pipelines.}\sphinxbfcode{pipe\_worker}}{\emph{pipe\_id}, \emph{pipe}, \emph{pipes\_dump}, \emph{X}}{}
Parallel pipelines execution.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{pipe\_id} : string
\begin{quote}

Pipeline identifier.
\end{quote}

\textbf{pipe} : list of tuples
\begin{quote}

Tuple containing a label and a sklearn Pipeline object.
\end{quote}

\textbf{pipes\_dump} : multiprocessing.Manager.dict
\begin{quote}

Dictionary containing the results of the parallel execution.
\end{quote}

\textbf{X} : array of float, shape
\begin{quote}

The input data matrix.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\phantomsection\label{index:module-adenine.core.analyze_results}\index{adenine.core.analyze\_results (module)}
Adenine analyzer module.
\index{est\_clst\_perf() (in module adenine.core.analyze\_results)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.core.analyze_results.est_clst_perf}\pysiglinewithargsret{\sphinxcode{adenine.core.analyze\_results.}\sphinxbfcode{est\_clst\_perf}}{\emph{root}, \emph{data\_in}, \emph{labels=None}, \emph{t\_labels=None}, \emph{model=None}, \emph{metric='euclidean'}}{}
Estimate the clustering performance.

This estimates the clustering performance by means of several indexes.
Results are saved in a tree-like structure in the root folder.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{root} : string
\begin{quote}

The root path for the output creation.
\end{quote}

\textbf{data\_in} : array of float, shape
\begin{quote}

The low space embedding estimated by the dimensinality reduction and
manifold learning algorithm.
\end{quote}

\textbf{labels} : array of float, shape
\begin{quote}

The label assignment performed by the clustering algorithm.
\end{quote}

\textbf{t\_labels} : array of float, shape
\begin{quote}

The true label vector; None if missing.
\end{quote}

\textbf{model} : sklearn or sklearn-like object
\begin{quote}

An instance of the class that evaluates a step. In particular this must
be a clustering model provided with the {\color{red}\bfseries{}clusters\_centers\_} attribute
(e.g. KMeans).
\end{quote}

\textbf{metric} : string
\begin{quote}

The metric used during the clustering algorithms.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{make\_df\_clst\_perf() (in module adenine.core.analyze\_results)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.core.analyze_results.make_df_clst_perf}\pysiglinewithargsret{\sphinxcode{adenine.core.analyze\_results.}\sphinxbfcode{make\_df\_clst\_perf}}{\emph{root}}{}
Summarize all the clustering performance estimations.

Given the output file produced by est\_clst\_perf(), this function groups all
of them together in friendly text and latex files, and saves the two files
produced in a tree-like structure in the root folder.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{root} : string
\begin{quote}

The root path for the output creation.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_step\_attributes() (in module adenine.core.analyze\_results)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.core.analyze_results.get_step_attributes}\pysiglinewithargsret{\sphinxcode{adenine.core.analyze\_results.}\sphinxbfcode{get\_step\_attributes}}{\emph{step}, \emph{pos}}{}
Get the attributes of the input step.

This function returns the attributes (i.e. level, name, outcome) of the
input step. This comes handy when dealing with steps with more than one
parameter (e.g. KernelPCA `poly' or `rbf').
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{step} : list
\begin{quote}

A step coded by ade\_run.py as
{[}name, level, param, data\_out, data\_in, mdl obj, voronoi\_mdl\_obj{]}
\end{quote}

\textbf{pos} : int
\begin{quote}

The position of the step inside the pipeline.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{name} : string
\begin{quote}

A unique name for the step (e.g. KernelPCA\_rbf).
\end{quote}

\textbf{level} : \{imputing, preproc, dimred, clustering\}
\begin{quote}

The step level.
\end{quote}

\textbf{data\_out} : array of float, shape
\begin{quote}

Where n\_out is n\_dimensions for dimensionality reduction step, or 1
for clustering.
\end{quote}

\textbf{data\_in} : array of float, shape
\begin{quote}

Where n\_in is n\_dimensions for preprocessing/imputing/dimensionality
reduction step, or n\_dim for clustering (because the data have already
been dimensionality reduced).
\end{quote}

\textbf{param} : dictionary
\begin{quote}

The parameters of the sklearn object implementing the algorithm.
\end{quote}

\textbf{mdl\_obj} : sklearn or sklearn-like object
\begin{quote}

This is an instance of the class that evaluates a step.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{analysis\_worker() (in module adenine.core.analyze\_results)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.core.analyze_results.analysis_worker}\pysiglinewithargsret{\sphinxcode{adenine.core.analyze\_results.}\sphinxbfcode{analysis\_worker}}{\emph{elem}, \emph{root}, \emph{y}, \emph{feat\_names}, \emph{index}, \emph{lock}}{}
Parallel pipelines analysis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{elem} : list
\begin{quote}

The first two element of this list are the pipe\_id and all the data of
that pipeline.
\end{quote}

\textbf{root} : string
\begin{quote}

The root path for the output creation.
\end{quote}

\textbf{y} : array of float, shape
\begin{quote}

The label vector; None if missing.
\end{quote}

\textbf{feat\_names} : array of integers (or strings), shape
\begin{quote}

The feature names; a range of numbers if missing.
\end{quote}

\textbf{index} : list of integers (or strings)
\begin{quote}

This is the samples identifier, if provided as first column (or row) of
of the input file. Otherwise it is just an incremental range of size
n\_samples.
\end{quote}

\textbf{lock} : multiprocessing.synchronize.Lock
\begin{quote}

Obtained by multiprocessing.Lock().
Needed for optional creation of directories.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Input Data}
\label{index:input-data}\label{index:module-adenine.utils.data_source}\index{adenine.utils.data\_source (module)}
This module is just a wrapper for some sklearn.datasets functions.
\index{generate\_gauss() (in module adenine.utils.data\_source)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.utils.data_source.generate_gauss}\pysiglinewithargsret{\sphinxcode{adenine.utils.data\_source.}\sphinxbfcode{generate\_gauss}}{\emph{mu=None}, \emph{std=None}, \emph{n\_sample=None}}{}
Create a Gaussian dataset.

Generates a dataset with n\_sample * n\_class examples and n\_dim dimensions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{mu} : array of float, shape
\begin{quote}

The mean of each class.
\end{quote}

\textbf{std} :  array of float, shape
\begin{quote}

The standard deviation of each Gaussian distribution.
\end{quote}

\textbf{n\_sample} : int
\begin{quote}

Number of point per class.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_custom() (in module adenine.utils.data\_source)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.utils.data_source.load_custom}\pysiglinewithargsret{\sphinxcode{adenine.utils.data\_source.}\sphinxbfcode{load\_custom}}{\emph{x\_filename}, \emph{y\_filename}, \emph{samples\_on='rows'}, \emph{**kwargs}}{}
Load a custom dataset.

This function loads the data matrix and the label vector returning a
unique sklearn-like object dataSetObj.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{x\_filename} : string
\begin{quote}

The data matrix file name.
\end{quote}

\textbf{y\_filename} : string
\begin{quote}

The label vector file name.
\end{quote}

\textbf{samples\_on} : string
\begin{quote}

This can be either in {[}'row', `rows'{]} if the samples lie on the row of
the input data matrix, or viceversa in {[}'col', `cols'{]} the other way
around.
\end{quote}

\textbf{kwargs} : dict
\begin{quote}

Arguments of pandas.read\_csv function.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{data} : sklearn.datasets.base.Bunch
\begin{quote}

An instance of the sklearn.datasets.base.Bunch class, the meaningful
attributes are .data, the data matrix, and .target, the label vector.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{load() (in module adenine.utils.data\_source)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.utils.data_source.load}\pysiglinewithargsret{\sphinxcode{adenine.utils.data\_source.}\sphinxbfcode{load}}{\emph{opt='custom'}, \emph{x\_filename=None}, \emph{y\_filename=None}, \emph{n\_samples=0}, \emph{samples\_on='rows'}, \emph{**kwargs}}{}
Load a specified dataset.

This function can be used either to load one of the standard scikit-learn
datasets or a different dataset saved as X.npy Y.npy in the working
directory.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{opt} : \{`iris', `digits', `diabetes', `boston', `circles', `moons',
\begin{quote}
\begin{quote}

`custom'\}, default: `custom'
\end{quote}

Name of a predefined dataset to be loaded.
\end{quote}

\textbf{x\_filename} : string, default
\begin{quote}

The data matrix file name.
\end{quote}

\textbf{y\_filename} : string, default
\begin{quote}

The label vector file name.
\end{quote}

\textbf{n\_samples} : int
\begin{quote}

The number of samples to be loaded. This comes handy when dealing with
large datasets. When n\_samples is less than the actual size of the
dataset this function performs a random subsampling that is stratified
w.r.t. the labels (if provided).
\end{quote}

\textbf{samples\_on} : string
\begin{quote}

This can be either in {[}'row', `rows'{]} if the samples lie on the row of
the input data matrix, or viceversa in {[}'col', `cols'{]} the other way
around.
\end{quote}

\textbf{data\_sep} : string
\begin{quote}

The data separator. For instance comma, tab, blank space, etc.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{X} : array of float, shape
\begin{quote}

The input data matrix.
\end{quote}

\textbf{y} : array of float, shape
\begin{quote}

The label vector; np.nan if missing.
\end{quote}

\textbf{feature\_names} : array of integers (or strings), shape
\begin{quote}

The feature names; a range of number if missing.
\end{quote}

\textbf{index} : list of integers (or strings)
\begin{quote}

This is the samples identifier, if provided as first column (or row) of
of the input file. Otherwise it is just an incremental range of size
n\_samples.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Plotting functions}
\label{index:plotting-functions}\label{index:module-adenine.core.plotting}\index{adenine.core.plotting (module)}
Adenine plotting module.
\index{silhouette() (in module adenine.core.plotting)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.core.plotting.silhouette}\pysiglinewithargsret{\sphinxcode{adenine.core.plotting.}\sphinxbfcode{silhouette}}{\emph{root}, \emph{data\_in}, \emph{labels}, \emph{model=None}}{}
Generate and save the silhouette plot of data\_in w.r.t labels.

This function generates the silhouette plot representing how data are
correctly clustered, based on labels.
The plots will be saved into the root folder in a tree-like structure.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{root} : string
\begin{quote}

The root path for the output creation
\end{quote}

\textbf{data\_in} : array of float, shape
\begin{quote}

The low space embedding estimated by the dimensionality reduction and
manifold learning algorithm.
\end{quote}

\textbf{labels} : array of float, shape
\begin{quote}

The label vector. It can contain true or estimated labels.
\end{quote}

\textbf{model} : sklearn or sklearn-like object
\begin{quote}

An instance of the class that evaluates a step.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{scatter() (in module adenine.core.plotting)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.core.plotting.scatter}\pysiglinewithargsret{\sphinxcode{adenine.core.plotting.}\sphinxbfcode{scatter}}{\emph{root}, \emph{data\_in}, \emph{labels=None}, \emph{true\_labels=False}, \emph{model=None}}{}
Generate the scatter plot of the dimensionality reduced data set.

This function generates the scatter plot representing the dimensionality
reduced data set. The plots will be saved into the root folder in a
tree-like structure.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{root} : string
\begin{quote}

The root path for the output creation
\end{quote}

\textbf{data\_in} : array of float, shape
\begin{quote}

The low space embedding estimated by the dimensinality reduction and
manifold learning algorithm.
\end{quote}

\textbf{labels} : array of float, shape
\begin{quote}

The label vector. It can contain true or estimated labels.
\end{quote}

\textbf{true\_labels} : boolean
\begin{quote}

Identify if labels contains true or estimated labels.
\end{quote}

\textbf{model} : sklearn or sklearn-like object
\begin{quote}

An instance of the class that evaluates a step. In particular this must
be a clustering model provided with the {\color{red}\bfseries{}clusters\_centers\_} attribute
(e.g. KMeans).
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{voronoi() (in module adenine.core.plotting)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.core.plotting.voronoi}\pysiglinewithargsret{\sphinxcode{adenine.core.plotting.}\sphinxbfcode{voronoi}}{\emph{root}, \emph{data\_in}, \emph{labels=None}, \emph{true\_labels=False}, \emph{model=None}}{}
Generate the Voronoi tessellation obtained from the clustering algorithm.

This function generates the Voronoi tessellation obtained from the
clustering algorithm applied on the data projected on a two-dimensional
embedding. The plots will be saved into the appropriate folder of the
tree-like structure created into the root folder.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{root} : string
\begin{quote}

The root path for the output creation
\end{quote}

\textbf{data\_in} : array of float, shape
\begin{quote}

The low space embedding estimated by the dimensinality reduction and
manifold learning algorithm.
\end{quote}

\textbf{labels} : array of int, shape
\begin{quote}

The result of the clustering step.
\end{quote}

\textbf{true\_labels} : boolean {[}deprecated{]}
\begin{quote}

Identify if labels contains true or estimated labels.
\end{quote}

\textbf{model} : sklearn or sklearn-like object
\begin{quote}

An instance of the class that evaluates a step. In particular this must
be a clustering model provided with the {\color{red}\bfseries{}clusters\_centers\_} attribute
(e.g. KMeans).
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{tree() (in module adenine.core.plotting)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.core.plotting.tree}\pysiglinewithargsret{\sphinxcode{adenine.core.plotting.}\sphinxbfcode{tree}}{\emph{root}, \emph{data\_in}, \emph{labels=None}, \emph{index=None}, \emph{model=None}}{}
Generate the tree structure obtained from the clustering algorithm.

This function generates the tree obtained from the clustering algorithm
applied on the data. The plots will be saved into the appropriate folder of
the tree-like structure created into the root folder.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{root} : string
\begin{quote}

The root path for the output creation
\end{quote}

\textbf{data\_in} : array of float, shape
\begin{quote}

The low space embedding estimated by the dimensinality reduction and
manifold learning algorithm.
\end{quote}

\textbf{labels} : array of int, shape
\begin{quote}

The result of the clustering step.
\end{quote}

\textbf{index} : list of integers (or strings)
\begin{quote}

This is the samples identifier, if provided as first column (or row) of
of the input file. Otherwise it is just an incremental range of size
n\_samples.
\end{quote}

\textbf{model} : sklearn or sklearn-like object
\begin{quote}

An instance of the class that evaluates a step. In particular this must
be a clustering model provided with the {\color{red}\bfseries{}clusters\_centers\_} attribute
(e.g. KMeans).
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{dendrogram() (in module adenine.core.plotting)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.core.plotting.dendrogram}\pysiglinewithargsret{\sphinxcode{adenine.core.plotting.}\sphinxbfcode{dendrogram}}{\emph{root}, \emph{data\_in}, \emph{labels=None}, \emph{index=None}, \emph{model=None}, \emph{n\_max=150}}{}
Generate and save the dendrogram obtained from the clustering algorithm.

This function generates the dendrogram obtained from the clustering
algorithm applied on the data. The plots will be saved into the appropriate
folder of the tree-like structure created into the root folder. The row
colors of the heatmap are the either true or estimated data labels.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{root} : string
\begin{quote}

The root path for the output creation
\end{quote}

\textbf{data\_in} : array of float, shape
\begin{quote}

The low space embedding estimated by the dimensinality reduction and
manifold learning algorithm.
\end{quote}

\textbf{labels} : array of int, shape
\begin{quote}

The result of the clustering step.
\end{quote}

\textbf{index} : list of integers (or strings)
\begin{quote}

This is the samples identifier, if provided as first column (or row) of
of the input file. Otherwise it is just an incremental range of size
n\_samples.
\end{quote}

\textbf{model} : sklearn or sklearn-like object
\begin{quote}

An instance of the class that evaluates a step. In particular this must
be a clustering model provided with the {\color{red}\bfseries{}clusters\_centers\_} attribute
(e.g. KMeans).
\end{quote}

\textbf{n\_max} : int, (INACTIVE)
\begin{quote}

The maximum number of samples to include in the dendrogram.
When the number of samples is bigger than n\_max, only n\_max samples
randomly extracted from the dataset are represented. The random
extraction is performed using
sklearn.model\_selection.StratifiedShuffleSplit
(or sklearn.cross\_validation.StratifiedShuffleSplit for legacy
reasons).
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{pcmagnitude() (in module adenine.core.plotting)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.core.plotting.pcmagnitude}\pysiglinewithargsret{\sphinxcode{adenine.core.plotting.}\sphinxbfcode{pcmagnitude}}{\emph{root}, \emph{points}, \emph{title='`}, \emph{ylabel='`}}{}
Plot the trend of principal components magnitude.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{root} : string
\begin{quote}

The root path for the output creation.
\end{quote}

\textbf{points} : array of float, shape
\begin{quote}

This could be the explained variance ratio or the eigenvalues of the
centered matrix, according to the PCA algorithm of choice, respectively
PCA or KernelPCA.
\end{quote}

\textbf{title} : string
\begin{quote}

Plot title.
\end{quote}

\textbf{ylabel} : string
\begin{quote}

Y-axis label.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{eigs() (in module adenine.core.plotting)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.core.plotting.eigs}\pysiglinewithargsret{\sphinxcode{adenine.core.plotting.}\sphinxbfcode{eigs}}{\emph{root}, \emph{affinity}, \emph{n\_clusters=0}, \emph{title='`}, \emph{ylabel='`}, \emph{normalised=True}, \emph{n\_components=20}, \emph{filename=None}, \emph{ylim='auto'}, \emph{rw=False}}{}
Plot eigenvalues of the Laplacian associated to data affinity matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{root} : string
\begin{quote}

The root path for the output creation.
\end{quote}

\textbf{affinity} : array of float, shape
\begin{quote}

The affinity matrix.
\end{quote}

\textbf{n\_clusters} : int, optional
\begin{quote}

The number of clusters.
\end{quote}

\textbf{title} : string, optional
\begin{quote}

Plot title.
\end{quote}

\textbf{ylabel} : string, optional
\begin{quote}

Y-axis label.
\end{quote}

\textbf{normalised} : boolean, optional, default True
\begin{quote}

Choose whether to normalise the Laplacian matrix.
\end{quote}

\textbf{n\_components} : int, optional, default 20
\begin{quote}

Number of components to show in the plot.
\end{quote}

\textbf{filename} : None or str, optional, default None
\begin{quote}

If not None, overrides default filename for saving the plot.
\end{quote}

\textbf{ylim} : `auto', None, tuple or list, optional, default `auto'
\begin{quote}

If `auto', choose the highest eigenvalue for the height of the plot.
If None, plt.ylim is not called (matplotlib default is used).
Otherwise, specify manually the desired ylim.
\end{quote}

\textbf{rw} : boolean, optional, default False
\begin{quote}

Normalise the Laplacian matrix as the random walks point of view.
This should be better suited with unclear data distributions.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Extra tools}
\label{index:extra-tools}\label{index:module-adenine.utils.extra}\index{adenine.utils.extra (module)}\index{Palette (class in adenine.utils.extra)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.utils.extra.Palette}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{adenine.utils.extra.}\sphinxbfcode{Palette}}{\emph{name='Set1'}, \emph{n\_colors=6}}{}
Wrapper for seaborn palette.

\end{fulllineitems}

\index{values\_iterator() (in module adenine.utils.extra)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.utils.extra.values_iterator}\pysiglinewithargsret{\sphinxcode{adenine.utils.extra.}\sphinxbfcode{values\_iterator}}{\emph{dictionary}}{}
Add support for python2 or 3 dictionary iterators.

\end{fulllineitems}

\index{items\_iterator() (in module adenine.utils.extra)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.utils.extra.items_iterator}\pysiglinewithargsret{\sphinxcode{adenine.utils.extra.}\sphinxbfcode{items\_iterator}}{\emph{dictionary}}{}
Add support for python2 or 3 dictionary iterators.

\end{fulllineitems}

\index{modified\_cartesian() (in module adenine.utils.extra)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.utils.extra.modified_cartesian}\pysiglinewithargsret{\sphinxcode{adenine.utils.extra.}\sphinxbfcode{modified\_cartesian}}{\emph{*args}, \emph{**kwargs}}{}
Modified Cartesian product.

This takes two (or more) lists and returns their Cartesian product.
If one of two list is empty this function returns the non-empty one.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{*args} : lists, length
\begin{quote}

The group of input lists.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{cp} : list
\begin{quote}

The Cartesian Product of the two (or more) nonempty input lists.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{make\_time\_flag() (in module adenine.utils.extra)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.utils.extra.make_time_flag}\pysiglinewithargsret{\sphinxcode{adenine.utils.extra.}\sphinxbfcode{make\_time\_flag}}{}{}
Generate a time flag.

This function simply generates a time flag using the current time.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\textbf{timeFlag} : string
\begin{quote}

A unique time flag.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{sec\_to\_time() (in module adenine.utils.extra)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.utils.extra.sec_to_time}\pysiglinewithargsret{\sphinxcode{adenine.utils.extra.}\sphinxbfcode{sec\_to\_time}}{\emph{seconds}}{}
Transform seconds into a formatted time string.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{seconds} : int
\begin{quote}

Seconds to be transformed.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{time} : string
\begin{quote}

A well formatted time string.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_time() (in module adenine.utils.extra)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.utils.extra.get_time}\pysiglinewithargsret{\sphinxcode{adenine.utils.extra.}\sphinxbfcode{get\_time}}{}{}
Get time of now, in string.

\end{fulllineitems}

\index{ensure\_symmetry() (in module adenine.utils.extra)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.utils.extra.ensure_symmetry}\pysiglinewithargsret{\sphinxcode{adenine.utils.extra.}\sphinxbfcode{ensure\_symmetry}}{\emph{X}}{}
Ensure matrix symmetry.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{X} : numpy.ndarray
\begin{quote}

Input matrix of precomputed pairwise distances.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{new\_X} : numpy.ndarray
\begin{quote}

Symmetric distance matrix. Values are averaged.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{timed() (in module adenine.utils.extra)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.utils.extra.timed}\pysiglinewithargsret{\sphinxcode{adenine.utils.extra.}\sphinxbfcode{timed}}{\emph{function}}{}
Decorator that measures wall time of the decored function.

\end{fulllineitems}

\index{set\_module\_defaults() (in module adenine.utils.extra)}

\begin{fulllineitems}
\phantomsection\label{index:adenine.utils.extra.set_module_defaults}\pysiglinewithargsret{\sphinxcode{adenine.utils.extra.}\sphinxbfcode{set\_module\_defaults}}{\emph{module}, \emph{dictionary}}{}
Set default variables of a module, given a dictionary.

Used after the loading of the configuration file to set some defaults.

\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{a}
\item {\texttt{adenine.core.analyze\_results}}, \pageref{index:module-adenine.core.analyze_results}
\item {\texttt{adenine.core.define\_pipeline}}, \pageref{index:module-adenine.core.define_pipeline}
\item {\texttt{adenine.core.pipelines}}, \pageref{index:module-adenine.core.pipelines}
\item {\texttt{adenine.core.plotting}}, \pageref{index:module-adenine.core.plotting}
\item {\texttt{adenine.utils.data\_source}}, \pageref{index:module-adenine.utils.data_source}
\item {\texttt{adenine.utils.extra}}, \pageref{index:module-adenine.utils.extra}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
