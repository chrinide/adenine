class Recenterer:
    """This class implements the data recentering.
    
    It is an sklearn 'transforms', it implements both a fit and a transform method and it compute the column-wise mean (.fit method) and returns the recentered data matrix (.transform method).
    """
    def __init__(self, data, label = []):
        self.X = data
        
    def fit(self,X):
        self.mean = np.mean(data, axis = 0)
        return self
    
    def transform(self,X):
        return self.X - self.mean

##################################################################

def tmpfun(pc, pipes, X):
    pipes_dump = dict()
    for i, pipe in enumerate(pipes):
            pipeID = 'pipe'+str(i)
            step_dump = dict()
            X_curr = np.array(X) # COPY X as X_curr (to avoid that the next pipeline works on the results of the previuos one)
            for j, step in enumerate(pipe): # step[0] -> step_label | step[1] -> sklearn (or sklearn-like) object (model)
                stepID = 'step'+str(j)
                # 1. define which level of step is this (i.e.: imputing, preproc, dimred, clustering, none)
                level = which_level(step[0])
                # 2. fit the model (whatever it is)
                if step[1].get_params().get('method') == 'hessian': # check hessian lle constraints
                    n_components = step[1].get_params().get('n_components')
                    step[1].set_params(n_neighbors = 1 + (n_components * (n_components + 3) / 2))
                step[1].fit(X_curr)
                # 3. evaluate (i.e. transform or predict according to the level)
                X_curr = evaluate(level, step[1], X_curr)
                # 4. save the results in a dictionary of dictionary of the form:
                # {'pipeID': {'stepID' : [level, params, res]}}
                step_dump[stepID] = [level, step[1].get_params(), X_curr]
            pipes_dump[pipeID] = step_dump
    return pipes_dump

##################################################################

else:
        # Run using pplus
        logging.info("Parallel")
        
        
        pc = pplus.PPlusConnection(debug=True)
        print('Starting experiment with id %s' % pc.id)
        print('Master session id %s' % pc.session_id)
        
        for pipe in enumerate(pipes):
            pc.submit(tmpfun, args =(pipes, X), depfuncs = (which_level,))
        
        results = pc.collect()
        # print results
