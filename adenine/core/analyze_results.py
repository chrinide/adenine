#!/usr/bin/python
# -*- coding: utf-8 -*-

import os
import logging
import numpy as np
from random import choice
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

def make_scatter(root = (), embedding = (), model_param = (), trueLabel = np.nan):
    """Generate and save the scatter plot of the dimensionality reduced data set.
    
    This function generates the scatter plot representing the dimensionality reduced data set. The plots will be saved into the root folder in a tree-like structure.
    
    Parameters
    -----------
    root : string
        The root path for the output creation
    
    embedding : array of float, shape : (n_samples, n_dimensions)
        The low space embedding estimated by the dimensinality reduction and manifold learning algorithm.
        
    model_param : dictionary
        The parameters of the dimensionality reduciont and manifold learning algorithm.
        
    trueLabel : array of float, shape : n_samples
        The true label vector; np.nan if missing (useful for plotting reasons).
    """
    n_samples, n_dim = embedding.shape
    
    # Define plot color
    if not np.isnan(trueLabel[0]):
        y = trueLabel # use the labels if provided
        _hue = 'Classes'
    else:
        colors = ['b','g','r','c','m','y','k']
        c, y = choice(colors), list()
        #for i in range(0,n_samples): y.append(c)
        y = np.zeros((n_samples))
        _hue = ' '
    
    # Define the fileName
    fileName = os.path.basename(root)
    # Define the plot title
    for i, t in enumerate(root.split(os.sep)): # something like ['results', 'ade_debug_', 'Standardize', 'PCA']
        if t[0:5] == '_ade': break
    title = str("$\mapsto$").join(root.split(os.sep)[i-1:])
    
    # Create pandas data frame (needed by sns)
    X = embedding[:,:2]
    df = pd.DataFrame(data = np.hstack((X,y[:,np.newaxis])), columns = ["$x_1$","$x_2$",_hue])
    # Generate seaborn plot
    g = sns.FacetGrid(df, hue=_hue, palette="Set1", size=5, legend_out=False)
    g.map(plt.scatter, "$x_1$", "$x_2$", s=100, linewidth=.5, edgecolor="white")
    if _hue != ' ': g.add_legend()
    # g.set_xticklabels([])
    # g.set_yticklabels([])
    plt.title(title)
    plt.savefig(os.path.join(root,fileName))
    

def est_clst_perf(root = (), label = (), trueLabel = np.nan, model_param = ()):
    """Estimate the clustering performance.
    
    This function estimate the clustering performance by means of several indexes. Then eventually saves the results in a tree-like structure in the root folder.
    
    Parameters
    -----------
    root : string
        The root path for the output creation
        
    label : array of float, shape : n_samples
        The label assignment performed by the clusterin algorithm.
        
    trueLabel : array of float, shape : n_samples
        The true label vector; np.nan if missing.
    
    model_param : dictionary
        The parameters of the clustering algorithm.
    """
    pass


def get_step_attributes(step = (), pos = ()):
    """Get the attributes of the input step.
    
    This function returns the attributes (i.e. level, name, outcome) of the input step. This comes handy when dealing with steps with more than one parameter (e.g. KernelPCA 'poly' or 'rbf').
    
    Parameters
    -----------
    step : list
        A step coded by ade_run.py as [name, level, results, parameters]
        
    pos : int
        The position of the step inside the pipeline.
    
    Returns
    -----------
    name : string
        A unique name for the step (e.g. KernelPCA_rbf).
        
    level : {imputing, preproc, dimred, clustering}
        The step level.
        
    res : array of float, shape : (n_samples, n_out)
        Where n_out is n_dimensions for dimensionality reduction step, or 1 for clustering.
        
    param : dictionary
        The parameters of the sklearn object implementing the algorithm.
    """
    name = step[0]
    level = step[1] # {imputing, preproc, dimred, clustering}
    param = step[2]
    res = step[3]
    if level.lower() == 'none' and pos == 0: level = 'preproc'
    if level.lower() == 'none' and pos == 1: level = 'dimred'
    
    # Append additional parameters in the step name
    if name == 'KernelPCA':
        name += '_'+param['kernel']
    elif name == 'LLE':
        name += '_'+param['method']
    elif name == 'MDS':
        if param['metric'] == 'True':
            name += '_metric'
        else:
            name += '_nonmetric'
            
    logging.info("{} : {}".format(level,name)) 
    return level, res, name, param

def start(inputDict = (), rootFolder = (), y = np.nan):
    """Analyze the results of ade_run.
    
    This function analyze the dictionary generated by ade_run, generates the plots, and saves them in a tree-like folder structure in rootFolder.
    
    Parameters
    -----------
    inputDict : dictionary
        The dictionary created by ade_run.py on some data.
        
    rootFolder : string
        The root path for the output creation
        
    y : array of float, shape : n_samples
        The label vector; np.nan if missing.
    """
    for pipe in inputDict: # iterating over a dictionary gives you the keys
        outFolder = '' # where the results will be placed
        logging.info("------\n{} : \n".format(pipe))
        for i, step in enumerate(sorted(inputDict[pipe].keys())):
            
            # Tree-like folder structure definition
            step_level, step_res, step_name, step_param = get_step_attributes(inputDict[pipe][step], pos = i)
            
            # Output folder definition & creation
            outFolder = os.path.join(outFolder,step_name)
            if not os.path.exists(os.path.join(rootFolder, outFolder)):
                os.makedirs(os.path.join(rootFolder, outFolder))
            
            # Launch analysis
            if step_level == 'dimred':
                make_scatter(root = os.path.join(rootFolder, outFolder), embedding = step_res, trueLabel = y, model_param = step_param)
            if step_level == 'clustering':
                est_clst_perf(root = os.path.join(rootFolder, outFolder), label = step_res, trueLabel = y, model_param = step_param)
            
            